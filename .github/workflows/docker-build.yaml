name: Docker Build

on:
  workflow_call:
    inputs:
      image_name:
        description: 'Image name (without registry prefix)'
        required: true
        type: string
      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: 'Dockerfile'
      context:
        description: 'Build context path'
        required: false
        type: string
        default: '.'
      platforms:
        description: 'Target platforms (comma-separated)'
        required: false
        type: string
        default: 'linux/amd64'
      registry:
        description: 'Container registry'
        required: false
        type: string
        default: 'ghcr.io'
    secrets:
      REGISTRY_USERNAME:
        description: 'Registry username (optional, defaults to github.actor for GHCR)'
        required: false
      REGISTRY_PASSWORD:
        description: 'Registry password (optional, defaults to github.token for GHCR)'
        required: false
      GITOPS_APP_ID:
        description: 'GitHub App ID for GitOps updates (optional, only needed if gitops-image-replacer.json exists)'
        required: false
      GITOPS_APP_PRIVATE_KEY:
        description: 'GitHub App private key for GitOps updates (optional, only needed if gitops-image-replacer.json exists)'
        required: false
    outputs:
      version:
        description: 'Released version'
        value: ${{ jobs.prepare.outputs.version }}
      image:
        description: 'Full image reference'
        value: ${{ jobs.manifest.outputs.image }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      matrix: ${{ steps.matrix.outputs.matrix }}

    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install semantic-release
        run: |
          npm install -g semantic-release @semantic-release/github conventional-changelog-conventionalcommits

      - name: Use default config if none exists
        run: |
          if [ ! -f .releaserc.json ] && [ ! -f .releaserc ] && [ ! -f .releaserc.yaml ] && [ ! -f .releaserc.yml ] && [ ! -f release.config.js ]; then
            cat > .releaserc.json << 'EOF'
          {
            "branches": ["main", "master"],
            "plugins": [
              ["@semantic-release/commit-analyzer", {"preset": "conventionalcommits"}],
              "@semantic-release/release-notes-generator",
              "@semantic-release/github"
            ]
          }
          EOF
          fi

      - name: Semantic Release
        id: semantic
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" ]]; then
            OUTPUT=$(npx semantic-release 2>&1) || true
            echo "$OUTPUT"
            VERSION=$(echo "$OUTPUT" | grep -oP 'Published release \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
            echo "new_release_version=${VERSION}" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Determine version
        id: version
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          if [ -n "${{ steps.semantic.outputs.new_release_version }}" ]; then
            echo "version=${{ steps.semantic.outputs.new_release_version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

      - name: Build matrix
        id: matrix
        run: |
          # Build matrix with platform-to-runner mapping
          PLATFORMS='${{ inputs.platforms }}'
          MATRIX='{"include":['
          FIRST=true
          for PLATFORM in ${PLATFORMS//,/ }; do
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              MATRIX="${MATRIX},"
            fi
            case "${PLATFORM}" in
              linux/amd64)
                RUNNER="ubuntu-latest"
                ;;
              linux/arm64)
                RUNNER="ubuntu-24.04-arm"
                ;;
              *)
                RUNNER="ubuntu-latest"
                ;;
            esac
            MATRIX="${MATRIX}{\"platform\":\"${PLATFORM}\",\"runner\":\"${RUNNER}\"}"
          done
          MATRIX="${MATRIX}]}"
          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT

  build:
    needs: prepare
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set platform suffix
        id: platform
        run: |
          PLATFORM="${{ matrix.platform }}"
          SUFFIX="${PLATFORM//\//-}"
          echo "suffix=${SUFFIX}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD || github.token }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          platforms: ${{ matrix.platform }}
          push: true
          provenance: false
          tags: ${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image_name }}:${{ needs.prepare.outputs.version }}-${{ steps.platform.outputs.suffix }}
          cache-from: type=gha,scope=${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=${{ matrix.platform }}

  manifest:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.result.outputs.image }}

    permissions:
      packages: write

    steps:
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD || github.token }}

      - name: Create and push manifest
        id: manifest
        run: |
          IMAGE="${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image_name }}"
          VERSION="${{ needs.prepare.outputs.version }}"
          PLATFORMS="${{ inputs.platforms }}"

          # Build list of arch-specific images from platforms
          IMAGES=""
          for PLATFORM in ${PLATFORMS//,/ }; do
            SUFFIX="${PLATFORM//\//-}"
            IMAGES="${IMAGES} ${IMAGE}:${VERSION}-${SUFFIX}"
          done
          IMAGES=$(echo ${IMAGES} | xargs)  # trim whitespace

          # Create manifest for version tag
          docker manifest create ${IMAGE}:${VERSION} ${IMAGES}
          docker manifest push ${IMAGE}:${VERSION}

          # Create short sha tag (only if different from version)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          if [ "${SHORT_SHA}" != "${VERSION}" ]; then
            docker manifest create ${IMAGE}:${SHORT_SHA} ${IMAGES}
            docker manifest push ${IMAGE}:${SHORT_SHA}
          fi

          # Create semver tags if this is a release
          if [ -n "${{ needs.prepare.outputs.new_release_version }}" ]; then
            SEMVER="${{ needs.prepare.outputs.new_release_version }}"
            MAJOR_MINOR=$(echo "${SEMVER}" | cut -d. -f1,2)

            docker manifest create ${IMAGE}:${MAJOR_MINOR} ${IMAGES}
            docker manifest push ${IMAGE}:${MAJOR_MINOR}
          fi

          # Create latest tags on main branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Arch-specific latest tags
            for PLATFORM in ${PLATFORMS//,/ }; do
              SUFFIX="${PLATFORM//\//-}"
              docker manifest create ${IMAGE}:latest-${SUFFIX} ${IMAGE}:${VERSION}-${SUFFIX}
              docker manifest push ${IMAGE}:latest-${SUFFIX}
            done

            # Main latest manifest (multi-arch)
            docker manifest create ${IMAGE}:latest ${IMAGES}
            docker manifest push ${IMAGE}:latest
          fi

      - name: Set output
        id: result
        run: |
          echo "image=${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image_name }}:${{ needs.prepare.outputs.version }}" >> $GITHUB_OUTPUT

  gitops:
    needs: [prepare, manifest]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for GitOps config
        id: config
        run: |
          if [ -f "gitops-image-replacer.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::No gitops-image-replacer.json found, skipping GitOps update"
          fi

      - name: Generate GitHub App token
        id: app-token
        if: steps.config.outputs.exists == 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GITOPS_APP_ID }}
          private-key: ${{ secrets.GITOPS_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Install gitops-image-replacer
        if: steps.config.outputs.exists == 'true'
        run: pip install gitops-image-replacer

      - name: Update GitOps repository
        if: steps.config.outputs.exists == 'true'
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          gitops-image-replacer --ci --apply "${{ needs.manifest.outputs.image }}"
